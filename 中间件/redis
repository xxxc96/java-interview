1、缓存穿透，缓存雪崩，缓存击穿
（1）缓存穿透：缓存穿透指的是读取数据时缓存未命中，这时将去读取数据库。缓存穿透有可能会被利用来进行恶意攻击。攻击者可以伪造一个数据库中并不存在的数据id，大量请求读取数据，
这时就会造成数据库的压力增大。
解决方法：缓存空值和布隆过滤器
缓存空值：当请求了一个数据库中不存在的数据时，我们会在缓存中添加一个空值，这样就能够防止使用不存在的数据来进行恶意攻击。但是这样会造成内存的损耗，因此需要为这些空值设置一个较短的过期时间。
布隆过滤器：布隆过滤器底层其实是一个bit数组，我们会将数据通过hash算法映射到bit数组中。本质上就是，将数据库中的所有数据的id映射到布隆过滤器中，在读取数据时，先访问布隆过滤器，
判断数据是否存在。若存在则查询数据，不存在则返回空值。在写入新的数据时，同时也要在布隆过滤器中写入新的id。
布隆过滤器存在一定的误判，因为采用hash算法，就一定会存在哈希冲突，这样就可能造成不在数据库中的元素被判断在布隆过滤器中存在，但是不在布隆过滤器中的元素一定不存在数据库中。
并且布隆过滤器不支持删除。
（2）缓存雪崩：缓存具有一定的失效时间，如果在某一个时刻缓存出现大面积失效，这一现象就是缓存雪崩。在发生缓存雪崩时，读取数据的请求流量将都会被打到数据库上，这将会给数据库带来很大的压力。
解决方法：将缓存失效的时间分散开，在设置缓存失效时间时，在基础时间上再加上一个随机值，这样就可以避免大范围的缓存同时失效。
（3）缓存击穿：缓存中的数据可以分为热点数据和非热点数据，热点数据的并发量是非常大的。在某一个时刻，这些热点数据的缓存失效，那么这些大的并发量将会全部打到数据库上。
解决方法：设置互斥锁，当第一个线程访问发现缓存未命中时，就给其加上互斥锁，只有获取了该锁的当前线程才能去访问数据库，并将数据写入缓存，释放锁之后，其他线程将会继续从缓存中获取数据。

2、redis和memeCached的区别
（1）redis支持复杂的数据结构，memeCached支持的数据结构比较简单；
（2）redis支持数据的持久化，memeCached无法持久化数据，在断电时会丢失数据。
（3）使用底层模型不同它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

3、Redis为什么是单线程的？
因为redis的数据存储在内存中，如果采用多线程就会涉及到上下文的切换，这话费的时间可能会比读写花费的时间更长，因此不需要多线程。但是在持久化等涉及到io操作的过程时，个人认为需要多线程。

4、Redis 支持的数据类型有哪些？
字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）

5、怎么保证缓存和数据库数据的一致性？
目前常用的数据更新模式为先更新数据库，再删除缓存，因此只有在缓存删除失败的时候会造成不一致，因此可以考虑在缓存删除失败之后，将该操作提交给消息队列，交给一个异步的线程去进行。

6、redis持久化
Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。

7、Redis怎么实现分布式锁？
redis实现分布式锁主要是给予setnx，在线程想要获取锁的时候，会尝试向redis中写入一个代表锁的key，如果在此之前没有线程持有该锁，则可以正常写入，并需要设置一个锁的过期时间。如果redis中存在
该key，且未超时，则代表获取锁失败，需要等待锁的释放。
缺陷：redis实现分布式锁仍然存在缺点。当持有锁的线程发生阻塞时，锁的过期时间到了。这时其他线程将会获取锁，这时阻塞的线程恢复之后，执行到锁的释放，就会释放不属于自己的锁。因此，要设置合适的锁超时
时间，并且在获取锁的时候，要设置一个随机的字符串。
传送门： https://blog.csdn.net/matt8/article/details/64442064

8、redis如何做内存优化
（1）缩减键值消耗：在能够充分描述key的含义的情况下，尽量缩减key的长度；而对value的缩减通常是将value序列化为二进制序列。
（2）共享对象池：对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。
所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。

9、Redis淘汰策略有哪些？
当前Redis支持的淘汰策略有6种：//（1）针对全体key；（2）仅针对设置了过期时间的key
1. volatile-lru：从设置过期时间的数据集(server.db[i].expires)中挑选出最近最少使用的数据淘汰。没有设置过期时间的key不会被淘汰，这样就可以在增加内存空间的同时保证需要持久化的数据不会丢失。
2. volatile-ttl：从设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰。
3. volatile-random：从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰。当内存达到限制无法写入非过期时间的数据集时，可以通过该淘汰策略在主键空间中随机移除某个key。
4. allkeys-lru：从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰，该策略要淘汰的key面向的是全体key集合，而非过期的key集合。
5. allkeys-random：从数据集(server.db[i].dict)中选择任意数据淘汰。
6. no-enviction：禁止驱逐数据，也就是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失，这也是系统默认的
一种淘汰策略。

10、redis的优缺点
优点：
1 读写性能优异，从内存当中进行IO读写速度快。
2 支持数据持久化，支持AOF和RDB两种持久化方式(由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，
当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，一种是RDB持久化:指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，
写入成功后，再替换之前的文件，用二进制压缩存储。还有一种是AOF持久化：以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。）
3 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。
4 数据结构丰富：除了支持string类型的value外还支持string、hash、set、sortedset、list等数据结构。
5 Redis是单线程多CPU，这样速度更快。因为单线程，没有线程切换的开销，不需要考虑加锁释放锁，也就没有死锁的问题。单线程-多路复用IO模型。效率高。
缺点：
1 主从同步，如果主机宕机，宕机前有一部分数据没有同步到从机，会导致数据不一致。
2.主从同步，数据同步会有延迟。
3.读写分离，主机写的负载量太大，也会导致主机的宕机

11、redis线程模型
https://blog.csdn.net/ShiLuoHeroKing/article/details/107551435

12、事务的ACID
https://zhuanlan.zhihu.com/p/27789602

13、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
使用keys指令可以扫出指定模式的key列表。
对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？
这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，
scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
