1、缓存穿透，缓存雪崩，缓存击穿
（1）缓存穿透：缓存穿透指的是读取数据时缓存未命中，这时将去读取数据库。缓存穿透有可能会被利用来进行恶意攻击。攻击者可以伪造一个数据库中并不存在的数据id，大量请求读取数据，
这时就会造成数据库的压力增大。
解决方法：缓存空值和布隆过滤器
缓存空值：当请求了一个数据库中不存在的数据时，我们会在缓存中添加一个空值，这样就能够防止使用不存在的数据来进行恶意攻击。但是这样会造成内存的损耗，因此需要为这些空值设置一个较短的过期时间。
布隆过滤器：布隆过滤器底层其实是一个bit数组，我们会将数据通过hash算法映射到bit数组中。本质上就是，将数据库中的所有数据的id映射到布隆过滤器中，在读取数据时，先访问布隆过滤器，
判断数据是否存在。若存在则查询数据，不存在则返回空值。在写入新的数据时，同时也要在布隆过滤器中写入新的id。
布隆过滤器存在一定的误判，因为采用hash算法，就一定会存在哈希冲突，这样就可能造成不在数据库中的元素被判断在布隆过滤器中存在，但是不在布隆过滤器中的元素一定不存在数据库中。
并且布隆过滤器不支持删除。
（2）缓存雪崩：缓存具有一定的失效时间，如果在某一个时刻缓存出现大面积失效，这一现象就是缓存雪崩。在发生缓存雪崩时，读取数据的请求流量将都会被打到数据库上，这将会给数据库带来很大的压力。
解决方法：将缓存失效的时间分散开，在设置缓存失效时间时，在基础时间上再加上一个随机值，这样就可以避免大范围的缓存同时失效。
（3）缓存击穿：缓存中的数据可以分为热点数据和非热点数据，热点数据的并发量是非常大的。在某一个时刻，这些热点数据的缓存失效，那么这些大的并发量将会全部打到数据库上。
解决方法：设置互斥锁，当第一个线程访问发现缓存未命中时，就给其加上互斥锁，只有获取了该锁的当前线程才能去访问数据库，并将数据写入缓存，释放锁之后，其他线程将会继续从缓存中获取数据。

2、redis和memeCached的区别
（1）redis支持复杂的数据结构，memeCached支持的数据结构比较简单；
（2）redis支持数据的持久化，memeCached无法持久化数据，在断电时会丢失数据。
（3）使用底层模型不同它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

3、Redis为什么是单线程的？
因为redis的数据存储在内存中，如果采用多线程就会涉及到上下文的切换，这话费的时间可能会比读写花费的时间更长，因此不需要多线程。但是在持久化等涉及到io操作的过程时，个人认为需要多线程。

4、Redis 支持的数据类型有哪些？
字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）

5、怎么保证缓存和数据库数据的一致性？
目前常用的数据更新模式为先更新数据库，再删除缓存，因此只有在缓存删除失败的时候会造成不一致，因此可以考虑在缓存删除失败之后，将该操作提交给消息队列，交给一个异步的线程去进行。

6、redis持久化
Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。

7、Redis怎么实现分布式锁？
redis实现分布式锁主要是给予setnx，在线程想要获取锁的时候，会尝试向redis中写入一个代表锁的key，如果在此之前没有线程持有该锁，则可以正常写入，并需要设置一个锁的过期时间。如果redis中存在
该key，且未超时，则代表获取锁失败，需要等待锁的释放。
缺陷：redis实现分布式锁仍然存在缺点。当持有锁的线程发生阻塞时，锁的过期时间到了。这时其他线程将会获取锁，这时阻塞的线程恢复之后，执行到锁的释放，就会释放不属于自己的锁。因此，要设置合适的锁超时
时间，并且在获取锁的时候，要设置一个随机的字符串。
传送门： https://blog.csdn.net/matt8/article/details/64442064

8、redis如何做内存优化
（1）缩减键值消耗：在能够充分描述key的含义的情况下，尽量缩减key的长度；而对value的缩减通常是将value序列化为二进制序列。
（2）共享对象池：对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。
所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。
