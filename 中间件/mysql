1、事务的ACID
要实现事务的最终目的，需要几种机制组合才能实现，这几种机制就是事务的几个特性，分别原子性、隔离性、一致性、持久性。 用一句话总结来总结这几个特性之间的关系，
那就是“一致性是事务的最终目的，而原子性、隔离性、持久性其实都是为了实现一致性的手段”。
（1）原子性（Atomicity）
概念：一个事务必须是一系列操作的最小单元，这系列操作的过程中，要么整个执行，要么整个回滚，不存在只执行了其中某一个或者某几个步骤。
对应到上面的转账操作中，原子性就代表（检查余额、转账、到账）三个步骤就是一个整体，少了任何一个都不能称为一次转账，整个过程中检查余额、转账、到账要么整体都执行，要么一个失败就整体失败，
绝对不会出现某一个执行成功其它的都执行失败，或者某一个执行失败其它的操作执行成功的情况。
（2）隔离性（Isolation）
概念：隔离性是说两个事务的执行都是独立隔离开来的，事务之前不会相互影响，多个事务操作一个对象时会以串行等待的方式保证事务相互之间是隔离的：
小明和小芳各自有一本作业本，如果他们同时去写作业，这时他们都可以在各自作业本上写作业是相互不影响的。但是如果他们两个人只有一本作业本，但是他们都想去写作业怎么办，
那么就这个时候就只能等一个人先写完作业后，另外一个人才能写，要不然两个人同时在同一个作业本上写作业，那么肯定会乱套。所以这种两个事物操作同一个对象必须隔离开来不能相互影响的特性称为事务的隔离性。
（3）一致性（Consistency）
概念：事务要保证数据库整体数据的完整性和业务的数据的一致性，事务成功提交整体数据修改，事务错误则回滚到数据回到原来的状态；
如上面转账的案例，如果事务提交成功则A账户减金额，B账户则加对应的金额，数据库总体金额不变只是载体变了。如果事务出错则整体回滚，
无论到了上面的哪个步骤A和B的数据都会回到最事务开启前的状态保证数据的始终一致;
（4）(Durability）持久性：
概念：持久性是指一旦事务成功提交后，只要修改的数据都会进行持久化，不会因为异常、宕机而造成数据错误或丢失。

2、脏读，不可重复读和幻读
（1）脏读（读取未提交数据）
A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，
这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。
（2）不可重复读（前后多次读取，数据内容不一致）
事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，
此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。
（3）幻读（前后多次读取，数据总量不一致）
事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，
平白无故的多了几条数据，成为幻读。

不可重复读和幻读到底有什么区别呢？
(1) 不可重复读是读取了其他事务更改的数据，针对update操作
解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。
(2) 幻读是读取了其他事务新增的数据，针对insert和delete操作
解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

3、数据库的隔离级别
（1）读未提交RU
    一个事务还没提交时，它做的变更就能被别的事务看到，会出现幻读，不可重复读，脏读。
（2）读已提交RC
    一个事务提交之后，它做的变更才会被其他事务看到，会出现幻读，不可重复读，不会出现脏读。写数据加行级排他锁，这样写过程是无法读取的，直到事务处理完毕才释放排他锁。
    给读的数据加行级共享锁，这样读的时候也是无法写的，但是一旦读完该行就释放共享锁，MySQL会在SQL语句开始执行时创建一个视图
（3）可重复读RR
    一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。会出现幻读，不会出现不可重复读，脏读。给写的数据加行级排他锁，事务结束释放，给读的数据加行级共享锁，事务结束后释放。
    MySQL会在事物开始时创建一个一致性视图(接下面的MVCC)，事物结束时销毁
（4）可串行化S
    当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。不会出现幻读，不可重复读，脏读。事务读数据则加表级共享锁，事务写数据则加表级排他锁
注意：MVCC如何实现数据库读已提交和可重复读这两种隔离级别：读已提交创建的视图会变化，当事物提交成功之后，会改变视图。可重复读创建的视图在整个执行过程中不会发生变化。
https://blog.csdn.net/SCUTJAY/article/details/104653599

4、数据库范式
（1）第一范式：所有的列不能再拆分
（2）第二范式：所有的非主关键字需要依赖于所有的主关键字，而不能仅仅依赖一部分
（3）第三范式：所有的非主关键字不能依赖于其他的非主关键字
